"""
Предложете соодветна репрезентација и напишете ги потребните функции во Python за да се реши следниот проблем
за кој една можна почетна состојба е прикажана на сликата Balls1.

На табла со димензии N x N, каде N > 3 е непарен природен број, поставени се топчиња.
Некои од полињата се неупотребливи т.е. во нив никогаш не може да се поставуваат топчиња
(на Слика Balls1 ваквите полиња се обоени со црна боја). Топчињата не се разликуваат помеѓу себе.
Со избор (кликнување) на кое било топче може да се направи преместување на тоа топче од полето во кое се наоѓа
-> преку едно поле (во една од шесте насоки: горе-десно, горе-лево, долу-десно, долу-лево, лево или десно),
но само ако „прескокнатото“ поле содржи друго топче и полето до „прескокнатото“ поле (во соодветната насока) е слободно.
Притоа, „прескокнатото“ топче исчезнува т.е се отстранува од таблата.
На пример, со кликнување на топчето кое се наоѓа во петтата редица и третата колона на таблата прикажана на Слика Balls1,
топчето кое се наоѓа во полето горе-лево од него ќе исчезне,
а кликнатото топче ќе се позиционира во полето што се наоѓа во третата редица и првата колона (види ја Слика Balls2!).

Не е дозволено топчињата да излегуваат од таблата.
Целта е на таблата да остане точно едно топче кое ќе биде позиционирано во централното поле во првата редица,
како што е прикажано на Слика 3. Потребно е проблемот да се реши во најмал број на потези,
т.е. со избирање (кликнување) на најмал можен број на топчиња.

За сите тест примери обликот на таблата е ист како на примерот даден на Слика Balls1.
За секој тест пример се менува големината N на таблата, како и бројот и распоредот на топчиња и неупотребливи полиња, соодветно.
На влез прво се чита должина и ширина на просторот. Потоа се чита бројот на топчиња.
Во наредните линии се читаат позициите на топчињата.
На крај се читаат бројот на препреките и во наредна линија позиција на препрека.

Движењата на топчињата (потезите) потребно е да ги именувате на следниот начин:
- GoreLevo: (x: x_val, y: y_val) - за преместување во насока горе-лево на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем)
- GoreDesno: (x: x_val, y: y_val) - за преместување во насока горе-десно на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем)
- DoluLevo: (x: x_val, y: y_val) - за преместување во насока долу-лево на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем)
- DoluDesno: (x: x_val, y: y_val) - за преместување во насока долу-десно на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем)
- Levo: (x: x_val, y: y_val) - за преместување налево на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем)
- Desno: (x: x_val, y: y_val) - за преместување надесно на топчето кое се наоѓа во x координатата x_val и y координатата y_val (ако таблата ја гледате во стандардниот координатен систем).

Input:
5
5
2,0
1,1
1,2
1,3
1,4
4
4,1
4,2
4,3
4,4

Result:
['Gore Levo: (x=2,y=0)', 'Desno: (x=0,y=2)', 'Gore Levo: (x=2,y=2)', 'Desno: (x=0,y=4)']
"""

from searching_framework import *


class Balls(Problem):
    def __init__(self, initial, forbidden, n, goal):
        super().__init__(initial, goal)
        self.forbidden = forbidden
        self.n = n

    def successor(self, state):
        successors = dict()
        moves = {"Gore Levo": (-2, 2),
                 "Gore Desno": (2, 2),
                 "Dolu Levo": (-2, -2),
                 "Dolu Desno": (2, -2),
                 "Levo": (-2, 0),
                 "Desno": (2, 0)}

        for ball in state:
            for move, (x, y) in moves.items():
                new_x, new_y = ball[0] + x, ball[1] + y
                jumped_ball = ball[0] + x // 2, ball[1] + y // 2
                if 0 <= new_x < self.n and 0 <= new_y < self.n and \
                        (new_x, new_y) not in forbidden and jumped_ball in state and \
                        (new_x, new_y) not in state:
                    new_state = [b for b in state if b != ball and b != jumped_ball]
                    new_state.append((new_x, new_y))
                    successors[f"{move}: (x={ball[0]},y={ball[1]})"] = tuple(new_state)

        return successors

    def actions(self, state):
        return self.successor(state).keys()

    def result(self, state, action):
        return self.successor(state)[action]

    def goal_test(self, state):
        return len(state) == 1 and state[0] == self.goal[0]


if __name__ == "__main__":
    n = int(input())
    m = int(input())
    balls = []
    for _ in range(m):
        pair = tuple(input().split("\."))
        pair = (int(pair[0]), int(pair[1]))
        balls.append(pair)
    balls = tuple(balls)
    forbidden = []
    m = int(input())
    for _ in range(m):
        pair = tuple(input().split("\."))
        pair = (int(pair[0]), int(pair[1]))
        forbidden.append(pair)
    forbidden = tuple(forbidden)
    goal_state = ((n // 2, n - 1),)
    problem = Balls(balls, forbidden, n, goal_state)
    result = breadth_first_graph_search(problem)
    if result is not None:
        print(result.solution())
    else:
        print("No solution")
